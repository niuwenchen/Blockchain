## 库
库类似于合约，但其目的是在一个特定地址只部署一次，且其代码由不同合约反复使用。
这意味着如果调用库函数，其代码在调用何种(calling contract)中执行，也就是说，this指向
调用合约，特别是来自调用合约中的storage可以被访问。 由于库是源代码中独立的一部分，只能访问
调用合约的状态变量，如果这些变量是显示的

库没有状态变量——不支持继承，不能接收以太币。可以包含结构类型，枚举

一旦在区块链中部署Solidity库，任何知道原型或者完整实现的人都可以使用它。Solidity
编译器需要有源代码，这样能确保所需要访问的方法在库中真实存在。


    library math {
    function addInt(int a,int b) returns( int c)
    {
        return a+b;
    }
    }

    contract libyaryeT{
        function data() returns (int d)
    {
        return math.addInt(1,2);
    }
    }
    其实库函数就是一个工具类
    
* 如果有许多合约，有一些共同代码，则可以把共同代码部署成一个库。这样将节省gas，因为gas也依赖于合约
的规模。因此，可以把库想象成合约的基础合约。 使用基础合约切分共同代码不会节省gas，因为在solidity中，
继承通过复制代码工作。由于库被当做基础合约，库里面带有内部可视性的函数被赋值给使用它的合约;


## Using for 
using A for B 可用于连接库函数(从库A到任意类型B)。 这些函数将被调用的对象作为第一个参数接受

